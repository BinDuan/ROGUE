---
title: "R Notebook"
output: html_notebook
---

#library
```{r}
library(SingleCellExperiment);library(tidyverse);library(reticulate);library(tidyverse)
library(ggplot2);library(scmap);library(fmsb);library(ggsci);library(scibet)
library(Seurat);library(M3Drop);library(ROCR);library(cluster);library(parallel)
```

#functions
```{r}
simul_da <- function(gene_means, r = 2, n_gene = 10000, n_cell = 2000, ZINB = F){
  sda <- matrix(data=NA, nrow=n_cell, ncol=n_gene, byrow=FALSE, dimnames=NULL)
  gene_means <- gene_means[gene_means > 0]
  u <- median(gene_means)
  for (i in 1:n_gene) {
    p <- gene_means[i]/(gene_means[i]+r)
    tmp <- rnbinom(n=n_cell, prob = 1-p, size = r)
    if(isTRUE(ZINB)){
      x <- -(mean(tmp)/u - 1.5)
      p <- 1/(1+exp(-x))
      n <- ceiling(n_cell*p)
      tmp[sample(n_cell,n)] <- 0
    }
    sda[,i] <- tmp
  }
  
  colnames(sda) <- paste("Gene", 1:ncol(sda), sep = '')
  rownames(sda) <- paste("Cell", 1:nrow(sda), sep = '')
  sda <- as.data.frame(sda)
  sda <- lapply(sda, as.numeric) %>% do.call("data.frame", .)
  return(sda)
}
simul_diff <- function(r = 2, n_gene = 10000, n_cell = 2000, n_diff = 200, sub = 0.5, ZINB = F){   
  
  gene_means <- exp(rnorm(n_gene, 0, sd = 2))
  
  sda1 <- simul_da(gene_means = gene_means, r = r, n_gene = n_gene, n_cell = n_cell, ZINB = ZINB)
  diff1 <- gene_means[1:n_diff]
  fc <- exp(rnorm(n_diff, mean = 0,sd = 2))
  
  tmp <- tibble(
    mean.expr1 = diff1,
    mean.expr2 = diff1*fc,
    fc = fc,
    Gene = paste("Gene", 1:n_diff, sep = "")
  )
  
  u <- median(gene_means)
  
  simul_expr <- function(.x, .l){
    p <- .x/(.x+r)
    tmp <- rnbinom(.l, prob = 1-p, size = r)
    if(isTRUE(ZINB)){
      x <- -(mean(tmp)/u - 1.5)
      p <- 1/(1+exp(-x))
      n <- ceiling(.l*p)
      tmp[sample(.l, n)] <- 0
    }
    
    return(tmp)
  }
  for (i in 1:nrow(tmp)) {
    expr1 <- simul_expr(tmp[i,]$mean.expr1, .l = ceiling(n_cell*sub))
    expr2 <- simul_expr(tmp[i,]$mean.expr2, .l = n_cell - ceiling(n_cell*sub))
    sda1[,i] <- c(expr1, expr2)
  }
  sda1 <- as.data.frame(sda1)
  sda <- list(sda1, tmp)
  return(sda)
}
Entropy <- function(expr, r = 0.01){
  tmp <- log(expr+1)
  entropy <- colMeans(tmp)
  mean.expr <- log(colMeans(expr)+r)
  
  ent_res <- tibble(
    Gene = colnames(expr),
    mean.expr = mean.expr,
    entropy = entropy
  )
  
  return(ent_res)
}
entropy_fit <- function(.x, span = 0.1){
  .x <- .x %>% dplyr::filter(is.finite(mean.expr)) %>% dplyr::filter(entropy > 0)
  fit <- loess(entropy~mean.expr, data = .x, span=span)
  prd <- predict(fit, .x$mean.expr)
  .x %>%
    dplyr::mutate(fit = prd) %>%
    dplyr::mutate(ds = fit - entropy) %>%
    dplyr::mutate(pv = 1-pnorm(.$ds, mean = mean(.$ds), sd = sd(.$ds))) %>%
    dplyr::filter(pv > 0.1) -> tmp
  
  fit <- loess(entropy~mean.expr, data = tmp, span=span)
  prd <- predict(fit, .x$mean.expr)
  .x %>%
    dplyr::mutate(fit = prd) %>%
    dplyr::mutate(ds = fit - entropy) %>%
    dplyr::filter(is.finite(ds)) %>%
    dplyr::mutate(pv = 1-pnorm(.$ds, mean = mean(.$ds), sd = sd(.$ds))) %>%
    dplyr::filter(pv > 0.1) -> tmp
  
  fit <- loess(entropy~mean.expr, data = tmp, span=span)
  prd <- predict(fit, .x$mean.expr)
  
  .x %>%
    dplyr::mutate(fit = prd) %>%
    dplyr::mutate(ds = fit - entropy) %>%
    dplyr::filter(is.finite(ds)) -> .x
  
  .x <- .x %>% dplyr::mutate(p.value = 1-pnorm(.x$ds, mean = mean(.x$ds), sd = sd(.x$ds)))
  p.adj <- p.adjust(.x$p.value, method = "fdr")
  .x <- .x %>% dplyr::mutate(p.adj = p.adj) %>% dplyr::arrange(desc(ds))
}
SE_fun <- function(expr, span = 0.1, r = 0.01){ 
  ent_res <- Entropy(expr, r = r)
  ent_res <- entropy_fit(ent_res, span = span) 
  return(ent_res)
}
m3d_fun <- function(expr){ 
  expr <- as.matrix(expr)
  expr <- t(expr)
  norm <- M3DropConvertData(expr, is.counts=TRUE)
  DEgenes <- M3Drop::M3DropFeatureSelection(norm, suppress.plot = T, mt_threshold = 2)
  DEgenes <- DEgenes %>% 
    dplyr::arrange(p.value)
  return(DEgenes)
}
HVG_fun <- function(expr){  
  expr <- t(expr)
  hvg.res <- BrenneckeGetVariableGenes(expr, suppress.plot = T, fdr = 2)
  return(hvg.res)
}
Gini_fun <- function(expr){ 
  
  calcul.gini = function(x, unbiased = TRUE, na.rm = FALSE){
    if (!is.numeric(x)){
      warning("'x' is not numeric; returning NA")
      return(NA)
    }
    if (!na.rm && any(na.ind = is.na(x)))
      stop("'x' contain NAs")
    if (na.rm)
      x = x[!na.ind]
    n = length(x)
    mu = mean(x)
    N = if (unbiased) n * (n - 1) else n * n
    ox = x[order(x)]
    dsum = drop(crossprod(2 * 1:n - n - 1,  ox))
    dsum / (mu * N)
  }
  
  expr <- t(expr)
  ExprM.RawCounts <- expr
  
  
  minCellNum = 0
  minGeneNum = 0
  expressed_cutoff = 1
  gini.bi = 0
  log2.expr.cutoffl = 0
  log2.expr.cutoffh = 30
  Gini.pvalue_cutoff = 0.0001
  Norm.Gini.cutoff = 1
  span = 0.9
  outlier_remove = 0.75
  GeneList = 1
  Gamma = 0.9
  diff.cutoff = 1
  lr.p_value_cutoff = 1e-5
  CountsForNormalized = 100000
  
  ExpressedinCell_per_gene=apply(ExprM.RawCounts,1,function(x) length(x[x > expressed_cutoff ]))
  nonMir = grep("MIR|Mir", rownames(ExprM.RawCounts), invert = T)  # because Mir gene is usually not accurate 
  Genelist = intersect(rownames(ExprM.RawCounts)[nonMir],rownames(ExprM.RawCounts)[ExpressedinCell_per_gene >= minCellNum])
  ExpressedGene_per_cell=apply(ExprM.RawCounts[Genelist,],2,function(x) length(x[x>0]))
  ExprM.RawCounts.filter = ExprM.RawCounts[Genelist,ExpressedGene_per_cell >= 0]
  
  if(gini.bi==0){
    gini = apply(as.data.frame(ExprM.RawCounts.filter), 1, function(x){calcul.gini(as.numeric(x)) } )    #theoretically, gini have very low chance to have a 1 value
    GiniIndex = as.data.frame(cbind(1:dim(ExprM.RawCounts.filter)[1], gini))
  } else {
    GiniIndex1 <- as.data.frame(apply(ExprM.RawCounts.filter, 1, function(x){calcul.gini(as.numeric(x)) } ) )
    GiniIndex2 <- as.data.frame(apply(ExprM.RawCounts.filter+0.00001, 1, function(x){calcul.gini(as.numeric(1/x)) } ) ) #bi directional
    GiniIndex  <- cbind(GiniIndex1, GiniIndex2)
    colnames(GiniIndex)=c("gini1","gini2")
    GiniIndex$gini2_sign = 0 - GiniIndex$gini2;
    GiniIndex$gini = apply(GiniIndex, 1, max)
    GiniIndex <- na.omit(GiniIndex)
    GiniIndex$gini_sign = GiniIndex$gini
    for(genei in 1:dim(GiniIndex)[1])
    {
      GiniIndex[genei, 5] = ifelse(  GiniIndex[genei, 1] > GiniIndex[genei,2], "up-regulation", "down-regulation") 
    }
  }
  
  Maxs          = apply(ExprM.RawCounts.filter,1,max)
  Means         = apply(ExprM.RawCounts.filter,1,mean)
  log2.Maxs     = log2(Maxs+0.1)
  ExprM.Stat1   = as.data.frame(cbind(Maxs,GiniIndex$gini,log2.Maxs))
  colnames(ExprM.Stat1) = c("Maxs","Gini","log2.Maxs")
  ExprM.Stat1 = ExprM.Stat1[ExprM.Stat1$log2.Maxs>log2.expr.cutoffl & ExprM.Stat1$log2.Maxs<=log2.expr.cutoffh ,]  # is this necessary?
  log2.Maxs = ExprM.Stat1$log2.Maxs
  Gini      = ExprM.Stat1$Gini
  Maxs      = ExprM.Stat1$Maxs
  
  # .3 fitting in max-gini space 
  Gini.loess.fit        = loess(Gini~log2.Maxs, span=span, degree=1)
  Normlized.Gini.Score  = Gini.loess.fit$residuals   #residuals = Gini - Gini.fitted
  Gini.fitted           = Gini.loess.fit$fitted    
  ExprM.Stat1           = as.data.frame(cbind(ExprM.Stat1[,c("Maxs","Gini", "log2.Maxs")], Normlized.Gini.Score, Gini.fitted))
  colnames(ExprM.Stat1) = c("Maxs","Gini","log2.Maxs", "Norm.Gini", "Gini.fitted")
  
  
   ### remove 25% of first round outlier genes, do second round loess
  Gini.loess.fit.residual = residuals(Gini.loess.fit)                               
  thresh.outlier = quantile(Gini.loess.fit.residual[Gini.loess.fit.residual>0], outlier_remove) 
  id.genes.loess.fit = which(Gini.loess.fit.residual < thresh.outlier)               
  id.outliers.loess.fit = which(Gini.loess.fit.residual >= thresh.outlier)          
  log2.Maxs.genes = log2.Maxs[id.genes.loess.fit]                                   
  log2.Maxs.outliers = log2.Maxs[id.outliers.loess.fit]                            
  Gini.loess.fit.2 = loess(Gini[id.genes.loess.fit]~log2.Maxs[id.genes.loess.fit], span=span, degree = 1)
  Gini.loess.fit.2.predict = predict(Gini.loess.fit.2)  
  
  Gini.loess.fit.2.x.y = cbind(log2.Maxs.genes,Gini.loess.fit.2.predict)
  Gini.loess.fit.2.x.y.uniq = as.data.frame(unique(Gini.loess.fit.2.x.y))
  Gini.loess.fit.2.x.y.uniq = Gini.loess.fit.2.x.y.uniq[order(Gini.loess.fit.2.x.y.uniq[,1]),]
  log2.Maxs.genes.sorted = log2.Maxs.genes[order(log2.Maxs.genes)]                   
  Gini.loess.fit.2.predict.sorted = Gini.loess.fit.2.predict[order(log2.Maxs.genes)] 
  #using Gini.loess.fit.2 as model, predict gini value for those outlier which are not used for build model.
  #for each max in outliers set, find the id of max value which is most close in fitted data set
  loc.outliers = apply(matrix(log2.Maxs.outliers),1,function(x){
    if(x<max(log2.Maxs.genes.sorted)){
      return(which(log2.Maxs.genes.sorted>=x)[1])
    }else{
      return(which.max(log2.Maxs.genes.sorted))
    }})                
  #check the results
  outlier_max_in_fit <- cbind(log2.Maxs.outliers, loc.outliers, log2.Maxs.genes.sorted[loc.outliers])
  
  #based on Gini.loess.fit.2, predict outliers which was not used for fitting
  Gini.outliers.predict = apply(cbind(seq(length(log2.Maxs.outliers)),log2.Maxs.outliers),1,function(x){
    id = x[1]
    value = x[2]
    if(value == log2.Maxs.genes.sorted[loc.outliers[id]]){
      return(as.numeric(Gini.loess.fit.2.x.y.uniq[which(Gini.loess.fit.2.x.y.uniq$log2.Maxs.genes>=value)[1],2]))
    }else{
      if(loc.outliers[id]>1){
        return(Gini.loess.fit.2.predict.sorted[loc.outliers[id]-1]+(Gini.loess.fit.2.predict.sorted[loc.outliers[id]]-Gini.loess.fit.2.predict.sorted[loc.outliers[id]-1])*(value-log2.Maxs.genes.sorted[loc.outliers[id]-1])/(log2.Maxs.genes.sorted[loc.outliers[id]]-log2.Maxs.genes.sorted[loc.outliers[id]-1]))
      }else{
        return(Gini.loess.fit.2.predict.sorted[2]-(Gini.loess.fit.2.predict.sorted[2]-Gini.loess.fit.2.predict.sorted[1])*(log2.Maxs.genes.sorted[2]-value)/(log2.Maxs.genes.sorted[2]-log2.Maxs.genes.sorted[1]))
      }
    }
  })
  
  #plot outliers predict results
  outliers.precit.x.y.uniq = as.data.frame(unique(cbind(log2.Maxs.outliers, Gini.outliers.predict)))
  #plot(outliers.precit.x.y.uniq)
  #plot whole fit2 
  colnames(outliers.precit.x.y.uniq) = colnames(Gini.loess.fit.2.x.y.uniq)
  Gini.loess.fit.2.full.x.y.uniq = rbind(Gini.loess.fit.2.x.y.uniq, outliers.precit.x.y.uniq)
  #plot(Gini.loess.fit.2.full.x.y.uniq)
  
  #calcualte Normlized.Gini.Score2
  Normlized.Gini.Score2                        = rep(0,length(Gini.loess.fit.residual))               
  Normlized.Gini.Score2[id.genes.loess.fit]    = residuals(Gini.loess.fit.2)                         
  Normlized.Gini.Score2[id.outliers.loess.fit] = Gini[id.outliers.loess.fit] - Gini.outliers.predict 
  
  Gini.fitted2           = Gini - Normlized.Gini.Score2         
  ExprM.Stat1            = as.data.frame(cbind(ExprM.Stat1[,c("Maxs","Gini", "log2.Maxs", "Gini.fitted", "Norm.Gini" )], Gini.fitted2, Normlized.Gini.Score2))
  colnames(ExprM.Stat1)  = c("Maxs","Gini","log2.Maxs", "Gini.fitted","Norm.Gini",  "Gini.fitted2", "Norm.Gini2")
  Gini.pvalue            = pnorm(-abs(scale(ExprM.Stat1$Norm.Gini2, center=TRUE,scale=TRUE)))
  ExprM.Stat2            = cbind(ExprM.Stat1, Gini.pvalue)  #first time use ExprM.Stat2
  colnames(ExprM.Stat2)  = c("Maxs","Gini","log2.Maxs", "Gini.fitted","Norm.Gini",  "Gini.fitted2", "Norm.Gini2", "p.value")
  
  ExprM.Stat2 %>%
    tibble::rownames_to_column(var = 'Gene') %>%
    dplyr::arrange(p.value)
}
get_sim_res <- function(sda){
  res1 <- SE_fun(sda[[1]], span = 0.1)
  res2 <- m3d_fun(sda[[1]])
  res3 <- Gini_fun(sda[[1]])
  res4 <- HVG_fun(sda[[1]])

  diff.gene <- sda[[2]] %>% dplyr::filter(fc <= 1/1.5 | fc >= 1.5) %>% dplyr::pull(Gene)
  tibble(res = list(res1,res2),
        method = c('SE','M3Drop')) %>%
   dplyr::mutate(
     auc = purrr::map_dbl(
     .x = res,
     .f = function(.x){
       cal_auc(.x, diff.gene)
          }
        )
      ) %>%
  dplyr::mutate(c = .y) %>%
  dplyr::mutate(sub = .x) %>% 
  dplyr::select(-res)
}
cal_auc <- function(.x, gene){
  .x <- .x %>% dplyr::mutate(diff = ifelse(Gene %in% gene, 0, 1))
  pred <- prediction(.x$p.value, .x$diff)
  perf <- performance(pred,'auc')
  auc <- perf@y.values[[1]]
  return(auc)
}
SEplot <- function(.x, point_size = 1, geom_line = T, p.adj = F, cutoff = 0.05){
  if(isFALSE(p.adj)){
    if(geom_line){
      .x %>%
        ggplot(aes(mean.expr, entropy)) +
        geom_point(colour = '#1E90FF', size = point_size) +
        geom_line(aes(mean.expr, fit), lwd = 0.7) +
        theme_bw() +
        theme(
            axis.title = element_text(size = 15,color="black"),
            axis.text = element_text(size = 15,color="black"),
            legend.title = element_text(size = 0),
            legend.text = element_text(size = 0),
            axis.text.y = element_text(color="black"),
            axis.text.x = element_text(color="black")
        ) +
        labs(
            x = "log(mean expression)",
            y = "expression entropy"
        ) -> p
    }
    else{
      .x %>%
        ggplot(aes(mean.expr, entropy)) +
        geom_point(colour = '#1E90FF', size = point_size) +
        #geom_line(aes(mean.expr, fit), lwd = 0.7) +
        theme_bw() +
        theme(
            axis.title = element_text(size = 15,color="black"),
            axis.text = element_text(size = 15,color="black"),
            legend.title = element_text(size = 0),
            legend.text = element_text(size = 0),
            axis.text.y = element_text(color="black"),
            axis.text.x = element_text(color="black")
        ) +
        labs(
            x = "log(mean expression)",
            y = "expression entropy"
        ) -> p
      }
    }
  if(isTRUE(p.adj)){
    .x <- .x %>% dplyr::mutate(sig = ifelse(p.adj <= cutoff, 1, 0))
    
    if(geom_line){
      .x %>%
        ggplot(aes(mean.expr, entropy)) +
        geom_point(aes(colour = factor(sig)), size = point_size) +
        geom_line(aes(mean.expr, fit), lwd = 0.7) +
        scale_color_manual(values = c("#1E90FF", "red")) +
        theme_bw() +
        theme(
            legend.position = "none",
            axis.title = element_text(size = 15,color="black"),
            axis.text = element_text(size = 15,color="black"),
            legend.title = element_text(size = 0),
            legend.text = element_text(size = 0),
            axis.text.y = element_text(color="black"),
            axis.text.x = element_text(color="black")
        ) +
        labs(
            x = "log(mean expression)",
            y = "expression entropy"
        ) -> p
      }
    
    else{
      .x %>%
        ggplot(aes(mean.expr, entropy)) +
        geom_point(aes(colour = factor(sig)), size = point_size) +
        #geom_line(aes(mean.expr, fit), lwd = 0.7) +
        scale_color_manual(values = c("#1E90FF", "red")) +
        theme_bw() +
        theme(
            legend.position = "none",
            axis.title = element_text(size = 15,color="black"),
            axis.text = element_text(size = 15,color="black"),
            legend.title = element_text(size = 0),
            legend.text = element_text(size = 0),
            axis.text.y = element_text(color="black"),
            axis.text.x = element_text(color="black")
        ) +
        labs(
            x = "log(mean expression)",
            y = "expression entropy"
        ) -> p
    }
  }
  return(p)
}
```

# SE model -- tabula muris
```{r, fig.width=6, fig.height=4}
expr <- matr_filter(expr, min.cells = 15)
colnames(expr) <- 1:ncol(expr)
ent.res <- SE_fun(expr, r = 0.01)
SEplot(ent.res, p.adj = T)
```

```{r, fig.width=6, fig.height=4}
expr.T <- readr::read_rds("/data1/pauling/02_data/01_Lung_Tcell/CD4.CD8.rds.gz")
expr.T <- expr.T %>% dplyr::select(-label)
ent.res2 <- SE_fun(expr.T, r = 1)
SEplot(ent.res2, p.adj = T) + xlim(0,8) + ylim(0,7.6)
```

```{r}
sda <- simul_diff(sub = 0.5, r = 2, ZINB = T)
res1 <- SE_fun(sda[[1]], r = 1)
res2 <- m3d_fun(sda[[1]])
res3 <- HVG_fun(sda[[1]])
res4 <- Gini_fun(sda[[1]])
```


#calculate AUC
```{r}
out.path <- "/home/pauling/projects/04_SEmodel/05_data_phase2/01.gene.selection.benchmark/02.sim.auc.data"
sub <- 0.01
AUC <- list()
for (r in c(2,3,5,10)) {
  for (i in 1:50) {
    sda <- simul_diff(sub = sub, r = r)
    res1 <- SE_fun(sda[[1]])
    res2 <- m3d_fun(sda[[1]])
    res3 <- HVG_fun(sda[[1]])
    res4 <- Gini_fun(sda[[1]])
  
    diff.gene <- sda[[2]] %>% 
      dplyr::filter(fc <= 1/1.5 | fc >= 1.5) %>% 
      dplyr::pull(Gene)
  
    auc1 <- cal_auc(res1, diff.gene)
    auc2 <- cal_auc(res2, diff.gene)
    auc3 <- cal_auc(res3, diff.gene)
    auc4 <- cal_auc(res4, diff.gene)
  
    AUC[[i]] <- c(auc1,auc2,auc3,auc4)
  }
}

pda <- Reduce(rbind,AUC) %>% as.matrix() %>% as.tibble()
r <- c(rep(2,50),rep(3,50),rep(5,50),rep(10,50))
pda <- pda %>% dplyr::mutate(r = r) %>% dplyr::mutate(sub = sub)
pda %>% readr::write_rds(file.path(out.path, paste("diff.gene.sim.auc", sub, ".rds.gz", sep = "")), 
                         compress = "gz")
```

#Simulation
```{r, fig.width=12.6, fig.height=4.6654}
#pda <- Reduce(rbind,AUC) %>% as.matrix()
pda <- readr::read_rds("/data1/pauling/04_SEmodel/05_data_phase2/01.gene.selection.benchmark/02.sim.auc.data.ZINB/diff.gene.sim.auc0.5.rds.gz")
colnames(pda) <- c("SEM","M3Drop","HVG","Gini","r","sub")
auc.plot <- function(pda, r.value){
    pda %>%
        as.tibble() %>%
        dplyr::filter(r == r.value) %>% 
        dplyr::select(-r,-sub) %>%
        tidyr::gather(key = "method", value = "AUC") %>%
        ggplot(aes(factor(method, levels = c("SEM","HVG","Gini","M3Drop")), AUC)) +
        geom_boxplot(aes(fill = method),outlier.shape = 21, outlier.fill = "white", lwd = 0.6) +
        #geom_jitter() +
        theme_bw() +
        theme(legend.position = "none",
              axis.text = element_text(size = 14, colour = "black"),
              axis.title = element_text(size = 15, colour = "black")) +
        labs(
            x = " ",
            y = "AUC"
        ) +
        scale_fill_manual(values = c("#00868B", "#009ACD", "#FF7F24", "#EE6AA7")) -> p_boxplot
    
    dat <- ggplot_build(p_boxplot)$data[[1]]
    dat$xsp <- 1/2 * (dat$xmax + dat$xmin) - 1/4 * (dat$xmax - dat$xmin)
    dat$xep <- 1/2 * (dat$xmax + dat$xmin) + 1/4 * (dat$xmax - dat$xmin)
    p_boxplot <- p_boxplot +
        geom_segment(data = dat,  aes(x = xmin, xend = xmax, y = middle, yend = middle), colour = "black", size = 1) +
        geom_segment(data = dat,  aes(x = xsp, xend = xep, y = ymin, yend = ymin), colour = "black", size = 1) +
        geom_segment(data = dat,  aes(x = xsp, xend = xep, y = ymax, yend = ymax), colour = "black", size = 1)
    return(p_boxplot)
}

p1 <- auc.plot(pda, r.value = 2)
p2 <- auc.plot(pda, r.value = 3)
p3 <- auc.plot(pda, r.value = 5)
p4 <- auc.plot(pda, r.value = 10)
mp <- ggarrange(p1,p2,p3,p4, ncol = 4)

ggsave(filename = "auc.sub.0.5.pdf",
       plot = mp, 
       path = "/home/pauling/projects/04_SEmodel/04_figures/04_DE.benchmark/01.DE.benchmark/02.ZINB", 
       width = 12.6, height = 4.6654)
```

# Classification
```{r}
expr <- readr::read_rds("/home/pauling/projects/04_SEmodel/05_data_phase2/01.gene.selection.benchmark/01.classification.data/01.pbmc.rds.gz")
cda <- readr::read_rds("/home/pauling/projects/04_SEmodel/05_data_phase2/01.gene.selection.benchmark/01.classification.data/01.pbmc.cda.rds.gz")

acc <- list()
rf.fun <- function(expr, label, if.log = F){
  use_python('/home/pauling/anaconda3/bin/python')
  rf <- import('sklearn.ensemble')
  RF <- rf$RandomForestClassifier
  
  if(isTRUE(if.log)){
    expr <- log2(expr + 1)
  }
  
  label %>%
    dplyr::mutate(ID = 1:nrow(.)) %>%
    dplyr::sample_frac(0.7) %>%
    dplyr::pull(ID) -> index_id
  
  X_label <- label$label[index_id]
  Y_label <- label$label[-index_id]
  clf <- RF(n_estimators = 200L)
  
  res1 <- SE_fun(expr[index_id,], span = 0.1)
  res2 <- m3d_fun(expr[index_id,])
  res3 <- Gini_fun(expr[index_id,])
  res4 <- HVG_fun(expr[index_id,])
  
  tibble(res = list(res1,res2,res3,res4),
         method = c('SE','M3Drop','Gini','HVG')) %>%
    dplyr::mutate(
      auc = purrr::map(
        .x = res,
        .f = function(.x){
          tmp <- c()
          n <- 0
          for (num in c(30,50,100,200,300,500,1000,5000)) {
            n <- n + 1
            X_train <- as.matrix(expr[index_id, .x$Gene[1:num]])
            X_test <- as.matrix(expr[-index_id, .x$Gene[1:num]])
            clf$fit(X_train, X_label)
            prd <- clf$predict(X_test)
            CohenKappa <- tibble(
              ori = as.character(Y_label),
              prd = prd)
            
            CohenKappa %>%
              dplyr::filter(ori == prd) %>%
              nrow(.) -> accuracy
            
            tmp[n] <- accuracy/nrow(CohenKappa)
          }
          
          tibble(
            num = c(30,50,100,200,300,500,1000,5000),
            acc = tmp
          ) -> tmp
          
          return(tmp)
        }
      )
    ) %>% 
    dplyr::select(-res) -> fin_res
  
  print("done")
  return(fin_res)
}
for (i in 1:50) {
  idex <- cda %>% dplyr::group_by(label) %>% dplyr::sample_n(1500) %>% dplyr::pull(ID)
  tmp.cda <- cda[idex,]
  tmp.expr <- expr[idex,]
  acc[[i]] <- rf.fun(tmp.expr, tmp.cda)
  print(i)
}
```

```{r, fig.width=8, fig.height=4}
Reduce(rbind, acc) %>%
  dplyr::mutate(
    auc = purrr::map2(
      .x = method,
      .y = auc,
      .f = function(.x, .y){
        .y %>%
          dplyr::mutate(method = .x)
      }
    )
  ) -> res

pp <- readr::read_rds("/home/pauling/projects/04_SEmodel/05_data_phase2/01.gene.selection.benchmark/03.classification.res/Panc.xin.classification.rds.gz")

Reduce(rbind,pp$auc) %>%
  ggplot(aes(factor(num), acc)) +
  geom_boxplot(aes(colour = factor(method, levels = c("SE","Gini","M3Drop","HVG"))), outlier.shape = NA) +
  #stat_boxplot(geom = "errorbar", width=0.15, aes(colour = factor(method, levels = c("SE","Gini","M3Drop","HVG"))), position = "dodge2") +
  theme_bw() +
  theme(
    legend.position = 'top',
    axis.title = element_text(size = 15),
    axis.text = element_text(size = 15),
    legend.title = element_text(size = 0),
    legend.text = element_text(size = 13),
    axis.text.y = element_text(color="black"),
    axis.text.x = element_text(color="black")
  ) +
  scale_colour_manual(values = c("#EE6AA7", "#00868B", "#FF7F24", "#009ACD")) +
  labs(
    y = "Classification accuracy",
    x = ""
  )
```

#Classification pancreatic data
```{r}
sce <- readr::read_rds("/data1/pauling/01_classifier/01_data/05_CrossPlatform/Pancreas/baron-human.rds")
expr <- assays(sce)[['counts']]
expr <- t(expr)
cda <- colData(sce)
tibble(label = as.character(cda$cell_type1),
       cellid = rownames(cda)) %>%
  dplyr::mutate(ID = 1:nrow(.)) -> cda

cda <- cda %>% dplyr::filter(label %in% c("acinar","alpha","beta","delta","ductal", "activated_stellate", "quiescent_stellate")) 
expr <- expr[cda$ID,]
cda <- cda %>% dplyr::mutate(ID = 1:nrow(.))

pan.acc <- list()
for (i in 1:50) {
  idex <- cda %>% dplyr::group_by(label) %>% dplyr::sample_n(170) %>% dplyr::pull(ID)
  tmp.cda <- cda[idex,]
  tmp.expr <- expr[idex,]
  pan.acc[[i]] <- rf.fun(tmp.expr, tmp.cda)
  print(i)
}

expr %>% readr::write_rds("/home/pauling/projects/04_SEmodel/05_data_phase2/01.gene.selection.benchmark/01.classification.data/02.panc.rds.gz", compress = "gz")
cda %>% readr::write_rds("/home/pauling/projects/04_SEmodel/05_data_phase2/01.gene.selection.benchmark/01.classification.data/02.panc.cda.rds.gz", compress = "gz")
```

```{r}
path_matr <- '/home/et/data/muris/10x/count.feather'
path_meta <- '/home/et/data/muris/10x/meta.tsv'
path_gene <- '/home/et/data/muris/10x/genes.csv'

meta <- read.table(path_meta, header = T)
expr <- feather::read_feather(path_matr)
gene <- readr::read_csv(path_gene)
colnames(gene) <- c("X1","gene")

expr <- as.matrix(expr)
expr <- t(expr)
colnames(expr) <- gene$gene

meta %>%
  dplyr::filter(tissue == "Bladder") %>%
  dplyr::pull(label) %>%
  as.character() %>%
  table()

meta <- tibble(
  cellid = rownames(meta),
  label = as.character(meta$cell_ontology_class),
  tissue = as.character(meta$tissue)
)

cda <- meta %>% 
  dplyr::filter(tissue == "Bladder") %>% 
  #dplyr::filter(label != "dendritic cell") %>% 
  dplyr::mutate(ID = 1:nrow(.))

s.expr <- expr[cda$cellid,]

a[[2]] <- a[[2]] %>% dplyr::mutate(ID = 1:nrow(.))
acc <- list()
for (i in 1:50) {
  #idex <- cda %>% dplyr::group_by(label) %>% dplyr::sample_n(1000, replace = T) %>% dplyr::pull(ID) %>% unique()
  tmp.cda <- cda#cda[idex,]
  tmp.expr <- expr#s.expr[idex,]
  acc[[i]] <- rf.fun(tmp.expr, tmp.cda, if.log = T)
  print(i)
}

s.expr %>% readr::write_rds("/home/pauling/projects/04_SEmodel/05_data_phase2/01.gene.selection.benchmark/01.classification.data/07.muris.Bladder.rds.gz", compress = "gz")
cda %>% readr::write_rds("/home/pauling/projects/04_SEmodel/05_data_phase2/01.gene.selection.benchmark/01.classification.data/07.muris.cda.Bladder.rds.gz", compress = "gz")
```

#classification plot
```{r, fig.width=7, fig.height=4}
res.path <- "/home/pauling/projects/04_SEmodel/05_data_phase2/01.gene.selection.benchmark/03.classification.res/02.sm2"
out.path <- "/home/pauling/projects/04_SEmodel/04_figures/04_DE.benchmark/02.classification/02.sm2"
files <- list.files(res.path)
p <- list()
for (i in 1:length(files)) {
  acc <- readr::read_rds(file.path(res.path, files[i]))
  for (i in 1:length(files)) {
    acc <- readr::read_rds(file.path(res.path, files[i]))
    p[[i]] <- Reduce(rbind,acc$auc) %>%
        ggplot(aes(factor(num), acc)) +
        geom_boxplot(aes(colour = factor(method, levels = c("SE","Gini","M3Drop","HVG"))), outlier.shape = NA) +
        theme_bw() +
        theme(
            legend.position = 'top',
            axis.title = element_text(size = 15),
            axis.text = element_text(size = 15),
            legend.title = element_text(size = 0),
            legend.text = element_text(size = 13),
            axis.text.y = element_text(color="black"),
            axis.text.x = element_text(color="black")
        ) +
        scale_colour_manual(values = c("#EE6AA7", "#00868B", "#FF7F24", "#009ACD")) +
        labs(
            y = "Classification accuracy",
            x = ""
        )
    }
}

p.name <- c("Brain.nature","Digestive")
for (i in 1:2) {
  ggsave(plot = p[[i]], filename = paste0(p.name[i],".pdf"), path = out.path, width = 7, height = 4)
}

p[[1]]
```

```{r}
sce <- readr::read_rds("/home/pauling/projects/01_classifier/01_data/05_CrossPlatform/Pancreas/xin.rds")
expr <- assays(sce)[["normcounts"]]
expr <- t(expr)
cda <- colData(sce)
tibble(
  cellid = rownames(cda),
  label = cda$cell_type1
) -> cda
cda <- cda %>% dplyr::filter(label %in% c("acinar","alpha","beta","delta","ductal","gamma"))
expr <- expr[cda$cellid,]
a <- list(expr, cda)
a %>% readr::write_rds("/home/pauling/projects/04_SEmodel/01_data/05_Gene_Selection_Benchmark/01_Classification/01_Input_data/Digestive.rds.gz", compress = "gz")
```

```{r}
expr <- expr %>% dplyr::filter(type == "expr_1") %>% dplyr::select(-type)
tibble(
  label = expr$label
) -> cda
expr <- as.matrix(expr[,-ncol(expr)])
```

#classification  smartseq
```{r}
load("/data1/et/muris/facs/FACS_all.Robj")
tiss_FACS@meta.data %>%
  tibble::rownames_to_column(var = "barcode") %>%
  dplyr::filter(tissue == "Heart") %>%
  dplyr::rename(label = cell_ontology_class) %>%
  dplyr::select(barcode, tissue, label) -> cda

expr <- t(tiss_FACS@data)
expr <- expr[cda$barcode,]
expr <- as.matrix(expr)
```

```{r}
#acc <- list()
for (i in 2:20) {
  acc[[i]] <- rf.fun(expr, cda)
  print(i)
}
```

```{r, fig.width=8, fig.height=4}
Reduce(rbind, acc) %>%
  dplyr::mutate(
    auc = purrr::map2(
      .x = method,
      .y = auc,
      .f = function(.x, .y){
        .y %>%
          dplyr::mutate(method = .x)
      }
    )
  ) -> res

res %>% readr::write_rds("/home/pauling/projects/04_SEmodel/05_data_phase2/01.gene.selection.benchmark/03.classification.res/Tabula.Muris.heart.classification.rds.gz", compress = "gz")

Reduce(rbind,res$auc) %>%
  ggplot(aes(factor(num), acc)) +
  geom_boxplot(aes(colour = factor(method, levels = c("SE","Gini","M3Drop","HVG"))), outlier.shape = NA) +
  #stat_boxplot(geom = "errorbar", width=0.15, aes(colour = factor(method, levels = c("SE","Gini","M3Drop","HVG"))), position = "dodge2") +
  theme_bw() +
  theme(
    legend.position = 'top',
    axis.title = element_text(size = 15),
    axis.text = element_text(size = 15),
    legend.title = element_text(size = 0),
    legend.text = element_text(size = 13),
    axis.text.y = element_text(color="black"),
    axis.text.x = element_text(color="black")
  ) +
  scale_colour_manual(values = c("#EE6AA7", "#00868B", "#FF7F24", "#009ACD")) +
  labs(
    y = "Classification accuracy",
    x = ""
  )
```

